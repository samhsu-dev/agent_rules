---
description: use those rules if and only if related to codes and programming
alwaysApply: false
---
# Code Quality Standards

## Control Flow Optimization
- Prefer early returns over nested conditionals
- Use guard clauses to minimize nesting
- Use `continue`/`break` instead of nested `if` blocks
- Keep logic flat, max 3 nesting levels

## Error Handling
- Catch specific exception types (avoid broad `except Exception`)
- Handle errors at appropriate abstraction level
- Preserve exception context with `from e`
- Provide meaningful error messages
- **Avoid silent fallback mechanisms**: Raise exceptions instead of silently falling back to alternative implementations
- **Fail fast**: Raise exceptions immediately on initialization/operation failure, do not silently degrade functionality
- **Exception-driven**: Use exceptions to communicate errors clearly, avoid hiding errors through fallback
- **Never silent fallback**: Never silently return empty values (empty strings, empty lists, None) when operations fail. Always log errors at appropriate level (ERROR for critical failures, WARNING for recoverable issues) and either raise exceptions or provide clear error messages in logs

## Code Structure
- Keep functions short (ideally < 20 lines)
- Extract complex logic into dedicated functions
- Use meaningful variable and function names
- **Relative imports**: Always use relative imports for internal modules within the same package/project. Do not use absolute imports for internal code.

## Performance
- Use context managers for resource management/cleanup
- Avoid unnecessary object creation in loops
- Check caches before expensive operations
- Optimize critical paths

## Documentation
- Use English for comments and docs
- Explain why (rationale) rather than what
- **No historical notes**: Do not include comments about code evolution or previous implementations
- **No iteration history**: Remove comments about previous design decisions that are no longer relevant
- **Focus on action/behavior**: Comments describe current behavior and constraints, not change history

### Docstring Standards (Public API)
- Document only public API (no leading underscore). Private methods: one-line usage comment only
- For functions/classes in design documents, docstrings must include all information from the corresponding design document section
- Include: one-sentence summary; constraints/assumptions/side effects; params; return; raises
- No redundancy, no implementation details, no examples
- Use structured Google-style format:
  - **Functions**: one sentence summary, followed by `Args:` section listing each parameter with description, `Returns:` section describing return value, and `Raises:` section listing exceptions when applicable
  - **Classes**: one sentence summary, followed by `Attributes:` section listing public attributes when applicable, and additional sections for important constraints/assumptions/side effects

## Type Safety
- Add type hints/annotations to all function parameters and return values
- Prefer specific types over generic ones
- **No Any**: Do not use `Any`. Use concrete types. If unsure, query Context7/docs.
- **Strict type checking**: Always enable strict type checking if the language supports it (e.g., `mypy --strict`, TypeScript `strict: true`, etc.)

## Input Contract & Invariants
- **Input Contract**: For each function, define the allowed input set (type + value range + required fields/invariants). Do not claim "any input is accepted".
- **Preconditions (fail fast)**: Validate the contract at function entry using guard clauses. If violated, raise the module/domain exception immediately.
- **Invariant-driven**: Encode "must hold" facts as executable checks, not comments or implicit assumptions.
- **Single downgrade point**: If upstream input is dynamic/loose, validate + normalize at the boundary layer. Core logic accepts only verified, strongly-typed/strongly-constrained data.
- **Single access path**: Access optional fields/variant structures via a single accessor/validator. Do not scatter presence/default/convert/error logic at call sites.
- **Helper domain declaration**: Helpers (e.g., `get_identifier_name(x)`) must state accepted input shapes. Out of scope inputs must raise, not return empty/`None`.
- **Consistent error semantics**: Same contract violation class → same exception type at the same layer. Do not mix "return empty" and "raise".

## Testing
- Prefer one assertion per test when practical
- Use descriptive test names (scenario + expectation)
- Follow Arrange–Act–Assert pattern
- Keep tests focused and isolated, use fixtures for common setup
- Cover positive and negative paths, assert error conditions explicitly
- **Contract-locked tests**: For each contract point, add "valid input" tests and "invalid input" tests that must raise the specified exception (not return empty results).

## API Design
- Use core module APIs directly
- Avoid direct dependencies on infrastructure services
- Prefer exception-driven error handling
- Build self-contained modules
- Keep data containers passive, avoid embedding behavior in simple data models
- Represent application logic as explicit callables/functions

## Code Quality Workflow
### Pre-Modification
- Run quality tools on target files
- Check score and identify issues
- Review warnings before making changes

### During Development
- Follow control flow optimization guidelines
- Follow naming conventions and code structure rules
- Add type hints and documentation
- Use context managers for resource management
- Use appropriate design patterns

### Post-Modification
- Run quality tools again
- Target score: 9.0+ for all modules
- Fix all warnings before proceeding
- **Never bypass or hide errors**: Do not use linter disable comments (e.g., `# pylint: disable=...`, `# type: ignore`, `# noqa`) to suppress warnings. Fix the underlying issues instead. Suppressing errors only improves scores artificially without solving the actual problems
- Apply formatting and import organization tools
- Verify structure follows standards

### Phase Completion Gate
- Run comprehensive quality checks
- Verify all files formatted consistently
- Run all unit tests
- Verify test coverage and quality
- Verify no critical issues remain
- All gates must pass before proceeding

## External Tool Integration
### Context7
- Resolve library IDs and get documentation
- Get docs before integration
- Focus on specific topics relevant to implementation

### Documentation Policy
- **NEVER** create summary/README after task completion
- **NEVER** create TEST_UPDATE_GUIDE.md or similar files
- Update existing TODO files in place
- Keep docs concise, avoid redundancy

## !!Refactory Rule!!
- Do not retain any old design elements. 
- Always use the new design and refactor the old design. 
- Do not keep change records in the code.

## Logging Standards
- Use Python standard `logging` module
- Get logger: `logger = logging.getLogger(__name__)` at module level
- Use lazy % formatting: `logger.info("Message: %s", var)` not f-strings
- **Add logs only when necessary**: each log must serve a clear debugging or monitoring purpose
- **No redundant logs**: avoid duplicate messages across modules for the same event
- **No trivial logs**: skip logging for simple operations (getters, setters, straightforward flows)
- Log levels:
  - DEBUG: complex logic diagnostics, non-obvious implementation details
  - INFO: key business results, flow milestones only (use sparingly)
  - WARNING: recoverable issues, unexpected but handled conditions, fallback operations
  - ERROR: failures requiring attention, critical operation failures
- **Layer appropriately**: high-level modules use INFO for results; low-level modules use DEBUG
- Include context in message string using % formatting
- Use `logger.exception()` for exceptions (auto-includes traceback)
- Avoid logging sensitive information (API keys, passwords, personal data)
